
# prints the usage and exits
# takes argument: $1
# the exit code
print_usage_and_exit() {
    local exit_code="${1:-"0"}"
    local usage_string="$doc_program_name"
    local synopsis=""
    local global_options=""
    local extra_sections=""
    local ind=0

# needs to be indented poorly
# so that newlines work properly in strings:
for i in "${doc_synopsis[@]}"; do
if [[ $ind -eq 0 ]]; then
synopsis="${synopsis}usage: $doc_program_name $i
"
else
synopsis="$synopsis   or: $doc_program_name $i
"
fi
((ind+=1))
done
ind=0
for i in "${doc_global_options[@]}"; do
if [[ $ind -eq 0 ]]; then
global_options="$global_options
$i"
ind=1
else
global_options="$global_options
\t$i
"
ind=0
fi
done
for i in "${doc_custom_sections[@]}"; do
local -n array="$i"
extra_sections="$extra_sections
${array[0]}
"
ind=1
while [[ $ind -lt ${#array[@]} ]]; do

if [[ $((ind%2)) -eq 1 ]]; then
extra_sections="$extra_sections
${array[ind]}"
else
extra_sections="$extra_sections
\t${array[ind]}
"
fi
((ind+=1))
done
done

local usage_string="$synopsis
Global Options:
$global_options
$extra_sections"

    echo -e "$usage_string"
    exit $exit_code
}

# args: $1 = the file to source.
# tries to source the file and
# returns whether or not the source
# was successful
source_without_error() {
    source "$1" > /dev/null 2>&1
    return $?
}

# args: $1 the name of the variable to check.
# returns true if variable is an array
# false otherwise
is_array() {
    if [[ "$(declare -p $1)" =~ "declare -a" ]]; then
        return 0
    fi
    return 1
}

# args: $1 the name of the branch to check
# returns true if the branch exists, false otherwise
branch_exists() {
    local it_exists=$(git branch --list $1 2>&1)
    if [[ ! -z $it_exists ]]; then
        return 0
    fi
    return 1
}

make_orphan_branch_without_error() {
    # create a new empty branch
    git checkout --orphan "$1" 2>&1
    if [[ $? != "0" ]]; then
        echo "Error creating an orphan branch: $1"
        return 1
    fi

    # woah this looks scary right?
    # normally yes, but we are on an orphan branch
    # which means that we still have the files from our
    # previous branch, and git is saying that we are
    # ready to commit them, but we dont want to commit because
    # we want to be on an empty branch. We can safely rm everything from
    # our git directory because we will get them back when we checkout
    # back to our previous branch.
    # NOTE THIS ONLY REMOVES FILES/FOLDERS THAT WERE COMMITED
    # THIS DOES NOT REMOVE UNCOMMITED FILES/FOLDERS.
    git rm -rf . > /dev/null 2>&1
    if [[ $? != "0" ]]; then
        echo "Error clearing out the orphan branch: $1"
        return 1
    fi

    return 0
}

# Checks if output branch of $1
# exists. If it already exists returns false.
# Otherwise, it creates the branch and returns
# true if there was no error.
make_output_branch_without_error() {
    if branch_exists "$1"; then
        echo "The branch $1 already exists."
        echo "Please use a different output repo name via the option:"
        echo "--output-branch \"some_new_branch\""
        echo "Or delete the branch and run this again."
        return 1
    fi
    echo "MAKING BRANCH: $1"
    git checkout -b "$1"
    if [[ $? != "0" ]]; then
        echo "Failed to create output branch: $1"
        return 1
    fi
    return 0
}

# Changes to the git repo's root directory.
# returns true if there was no error,
# false otherwise.
cd_into_toplevel_without_error() {
    repo_absolute_path=$(git rev-parse --show-toplevel 2>&1)
    if [[ $repo_absolute_path == *"fatal: not a git repo"* ]]; then
        echo "Failed to find git toplevel directory"
        echo "This script must be ran from within a git repository"
        return 1
    fi

    # TODO: should we do printouts?
    # echo "Changing to repo: $repo_absolute_path"
    cd "$repo_absolute_path" > /dev/null 2>&1
    return $?
}

# echoes out the current branch name
get_current_branch_name() {
    echo "$(git rev-parse --abbrev-ref HEAD)"
}

# args: $1 the remote_repo uri.
# sets the repo_name global variable
# with everything after the last slash
# and before the last dot.
get_repo_name_from_remote_repo() {
    local reponame="$1"
    # remove trailing slash if present:
    if [[ $reponame == *"/" ]]; then
        reponame=${reponame%?}
    fi

    # remove everything before last slash
    reponame="${reponame##*/}"
    # remove everything after the dot
    reponame="${reponame%.*}"
    repo_name="$reponame"
    return 0
}


# args: $1 the first arg
# passed to the program. Sets a global
# remote_repo, and repo_name arguments
# if it can parse the repo uri
# otherwise, returns false if failure.
get_remote_repo_from_args() {
    if \
    [[ $1 == "ssh://"* ]] || \
    [[ $1 == "git://"* ]] || \
    [[ $1 == "http://"* ]] || \
    [[ $1 == "https://"* ]] || \
    [[ $1 == "ftp://"* ]] || \
    [[ $1 == "ftps://"* ]] || \
    [[ $1 == "file://"* ]] || \
    [[ $1 =~ (.*)@(.*)\.(.*) ]]; then
        # set remote_repo, and repo_name variables and return success
        get_repo_name_from_remote_repo "$1"
        remote_repo="$1"
        return 0
    fi
    # the arg $1 is not a valid
    # remote uri, return false
    return 1
}
