
# prints the usage and exits
# takes argument: $1
# the exit code
print_usage_and_exit() {
    local exit_code="${1:-"0"}"
    echo "Usage:"
    echo "git split <out|in> <path/to/repo_file> [OPTIONS]"
    echo ""
    echo "Global options:"
    echo " --dry-run"
    echo "   does not actually modify/do anything. Just"
    echo "   outputs the commands that it would do without the"
    echo "   --dry-run option present."
    echo "   example:"
    echo "   git split out repo_file.sh --dry-run"
    echo ""
    echo " --output-branch <branch_name>"
    echo "   git split out, and git split in both create new"
    echo "   branches, that by default get named according"
    echo "   to the value of the 'repo_name' variable"
    echo "   providing --output-branch <branch_name> lets you"
    echo "   specify the name of the branch that will be created"
    echo "   if you don't want it to be named based on the 'repo_name'"
    echo "   example:"
    echo "   git split in repo_file.sh --output-branch my-branch"
    echo ""
    echo "split in options:"
    echo " --merge-branch <branch_name>"
    echo "   for git split in, the merge branch option lets you"
    echo "   split in from a local branch instead of a remote repository"
    echo "   <branch_name> must be a name of a branch that exists in your"
    echo "   local repository"
    echo "   example:"
    echo "   git split in repo_file.sh --merge-branch my-branch"
    echo ""
    exit $exit_code
}

# args: $1 = the file to source.
# tries to source the file and
# returns whether or not the source
# was successful
source_without_error() {
    source "$1" > /dev/null 2>&1
    return $?
}

# args: $1 the name of the variable to check.
# returns true if variable is an array
# false otherwise
is_array() {
    if [[ "$(declare -p $1)" =~ "declare -a" ]]; then
        return 0
    fi
    return 1
}

# args: $1 the name of the branch to check
# returns true if the branch exists, false otherwise
branch_exists() {
    local it_exists=$(git branch --list $1 2>&1)
    if [[ ! -z $it_exists ]]; then
        return 0
    fi
    return 1
}

make_orphan_branch_without_error() {
    # create a new empty branch
    git checkout --orphan "$1" 2>&1
    if [[ $? != "0" ]]; then
        echo "Error creating an orphan branch: $1"
        return 1
    fi

    # woah this looks scary right?
    # normally yes, but we are on an orphan branch
    # which means that we still have the files from our
    # previous branch, and git is saying that we are
    # ready to commit them, but we dont want to commit because
    # we want to be on an empty branch. We can safely rm everything from
    # our git directory because we will get them back when we checkout
    # back to our previous branch.
    # NOTE THIS ONLY REMOVES FILES/FOLDERS THAT WERE COMMITED
    # THIS DOES NOT REMOVE UNCOMMITED FILES/FOLDERS.
    git rm -rf . > /dev/null 2>&1
    if [[ $? != "0" ]]; then
        echo "Error clearing out the orphan branch: $1"
        return 1
    fi

    return 0
}

# Checks if output branch of $1
# exists. If it already exists returns false.
# Otherwise, it creates the branch and returns
# true if there was no error.
make_output_branch_without_error() {
    if branch_exists "$1"; then
        echo "The branch $1 already exists."
        echo "Please use a different output repo name via the option:"
        echo "--output-branch \"some_new_branch\""
        echo "Or delete the branch and run this again."
        return 1
    fi
    echo "MAKING BRANCH: $1"
    git checkout -b "$1"
    if [[ $? != "0" ]]; then
        echo "Failed to create output branch: $1"
        return 1
    fi
    return 0
}

# Changes to the git repo's root directory.
# returns true if there was no error,
# false otherwise.
cd_into_toplevel_without_error() {
    repo_absolute_path=$(git rev-parse --show-toplevel 2>&1)
    if [[ $repo_absolute_path == *"fatal: not a git repo"* ]]; then
        echo "Failed to find git toplevel directory"
        echo "This script must be ran from within a git repository"
        return 1
    fi

    # TODO: should we do printouts?
    # echo "Changing to repo: $repo_absolute_path"
    cd "$repo_absolute_path" > /dev/null 2>&1
    return $?
}

# echoes out the current branch name
get_current_branch_name() {
    echo "$(git rev-parse --abbrev-ref HEAD)"
}
