# if compiling this file individually, use:
# import ./helpers.bsc
# otherwise helpers.bsc already included from git-split.bsc

# assumes that the input file has been sourced
# validates the variables that the input file has set.
# takes arg: $1 = the name of the file that was sourced.
# echoes out error message and returns false if invalid.
# otherwise returns true
input_file_valid_in() {
    if [[ -z $repo_name ]]; then
        echo "The file: $1 does not include a 'repo_name' variable"
        echo "To split in a subrepo, it must include a repo name"
        return 1
    elif [[ -z $merge_branch ]] && [[ -z $remote_repo ]] && [[ -z $repo_name || -z $username ]]; then
        echo "The file: $1 does not contain a remote source to pull from"
        echo "You must provide either a 'remote_repo' URL as a string"
        echo "Or a 'repo_name' and a 'username'"
        echo "Alternatively, you can provide a '--merge-branch' option"
        echo "to use a local branch to merge in from instead of merging in"
        echo "from a remote source"
        return 1
    elif [[ -z $include && -z $include_as ]]; then
        echo "The file: $1 does not have an 'include' or an 'include_as' variable"
        echo "To split in a subrepo, the input file must contain at least one include file/folder"
        return 1
    elif [[ ! -z $include_as ]] && ! is_array "include_as"; then
        echo "The file: $1 contains an include_as variable, but this variable is not an array"
        echo "To use include_as functionality, make sure it is an array"
        return 1
    elif [[ ! -z $include_as ]] && [[ ! $((${#include_as[@]} % 2)) -eq 0 ]]; then
        echo "include_as array provided, but it has an odd length"
        echo "include_as must be even so every even argument"
        echo "is the source file, and every odd argument"
        echo "is the desired destination"
        return 1
    fi
    return 0
}

# given a list of arguments,
# the first being the name that you are searching for
# and the rest is an arbitrary list or keywords.
# returns true if the list of key words contains
# the first argument.
does_item_match_any_of() {
    local item_name="$1"
    shift
    for thing in "$@"; do
        if [[ $item_name == "$thing"* ]]; then
            return 0
        fi
    done

    return 1
}

# given a single argument: $1
# iterate over that folder, recursively
# and echo out a list of files, ignoring
# files that are git-ignored, and files
# that are not committed in the repo.
get_all_files_from() {
    local f_or_d="$1"

    if [[ -d "$f_or_d" ]]; then
        # all files/folders in f_or_d/ including
        # files/folders that start with a dot:
        for next in $f_or_d/* $f_or_d/.[^.]* ; do
            if ! git check-ignore "$next" > /dev/null 2>&1 ; then
                # only recurse as long as this is not a .gitignored file
                get_all_files_from "$next"
            fi
        done
    else
        # only echo out the file
        # if it actually has history in the git repo
        if git cat-file -e HEAD:"$f_or_d" > /dev/null 2>&1 ; then
            echo "$f_or_d"
        fi
    fi
}

# relies on previously defined variables:
# uses $merge_branch if set. If merge_branch
# is set, it does git merge $merge_branch
# otherwise it does
# git pull https://github.com/username/repo_name
populate_empty_branch_with_remote_commits() {
    # # populate the empty branch with the current master of the remote
    if [[ ! -z $merge_branch ]]; then
        # if user provided merge branch, use that instead of pull:
        if [[ ! -z $dry_run ]]; then
            echo "git merge $merge_branch"
        else
            git merge $merge_branch
        fi
    else
        if [[ ! -z $dry_run ]]; then
            echo "git pull https://github.com/$username/$repo_name"
        else
            git pull "https://github.com/$username/$repo_name"
        fi
    fi
}


# sources an input file that contains
# variables needed for splitting in
# a remote repository and (optionally) changing paths.
# back into this local repository.
# it uses previously defined variables:
# dry_run.
# If dry_run is defined, it will simply
# print out the commands instead of running them.
split_in() {
    # get a --merge-branch option if the user supplied it
    get_arg merge_branch,m "$@"
    get_arg verbose "$@"

    if [[ -z $1 ]]; then
        echo "Missing required input file"
        echo ""
        print_usage_and_exit $error_missing_input
    elif [[ ! -f $1 ]]; then
        echo "Failed to find input file: $1"
        echo ""
        print_usage_and_exit 2
    elif ! source_without_error "$1"; then
        echo "Failed to source input file: $1"
        echo "Is this a shell script file?"
        echo ""
        print_usage_and_exit 3
    elif ! input_file_valid_in "$1"; then
        echo ""
        print_usage_and_exit 4
    elif ! cd_into_toplevel_without_error; then
        echo ""
        print_usage_and_exit 6
    elif [[ ! -z $merge_branch ]] && ! branch_exists "$merge_branch"; then
        echo "You provided a merge branch: $merge_branch"
        echo "That does not exist."
        echo ""
        print_usage_and_exit 7
    fi

    # TODO: allow user to use an option --output-branch
    # instead of an env var
    local output_branch_name=${OUTPUT_BRANCH_NAME:-"$repo_name-reverse"}
    if [[ ! -z $dry_run ]]; then
        echo "git checkout --orphan $output_branch_name"
        echo "git rm -rf . > /dev/null"
    elif ! make_orphan_branch_without_error "$output_branch_name"; then
        echo ""
        print_usage_and_exit 5
    fi

    populate_empty_branch_with_remote_commits
    generate_repo_split_args_in
    generate_repo_split_strings_in

    if [[ ! -z $include_as_path_str ]]; then
        echo "git filter-repo --force --refs $output_branch_name $include_as_path_str"
        if [[ -z $dry_run ]]; then
            git filter-repo --force --refs $output_branch_name $include_as_path_str
        fi
    fi
}
