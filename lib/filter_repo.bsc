# These are helper functions
# that specifically apply to using
# git-filter-repo

# generates the repo_split_include array
# from the previously defined include variable
generate_repo_split_include() {
    if [[ ! -z $include ]] && is_array "include"; then
        for i in ${include[@]}; do
            repo_split_include+=($i)
        done
    elif [[ ! -z $include ]]; then
        # its a single string
        repo_split_include+=($include)
    fi
}

# generates the repo_split_exclude array
# from the previously defined exclude variable
generate_repo_split_exclude() {
    if [[ ! -z $exclude ]] && is_array "exclude"; then
        # its an array
        for i in ${exclude[@]}; do
            repo_split_exclude+=($i)
        done
    elif [[ ! -z $exclude ]]; then
        # its a single string
        repo_split_exclude+=($exclude)
    fi
}

# creates 3 repo split variables:
# repo_split_exclude, repo_split_include, and
# repo_split_include_as. Then iterates over
# the user defined include, or include_as, or
# exclude variables, and fills in
# the repo_split_* arrays as needed.
generate_repo_split_args_out() {
    repo_split_exclude=()
    repo_split_include=()
    repo_split_include_as=()

    generate_repo_split_include
    generate_repo_split_exclude

    if [[ ! -z $include_as ]] && is_array "include_as"; then
        include_as_len=${#include_as[@]}
        include_as_index=0
        previous_i=""
        while [[ $include_as_index -lt $include_as_len ]]; do
            i=${include_as[include_as_index]}
            if [[ $((include_as_index%2)) -eq 0 ]]; then
                # even
                previous_i="$i"
                repo_split_include+=($i)
            else
                repo_split_include_as+=("$previous_i:$i")
            fi
            ((include_as_index+=1))
        done
    fi
}

# creates 2 repo split variables:
# repo_split_include, and
# repo_split_include_as. Then iterates over
# the user defined include, or include_as, or
# variables, and fills in
# the repo_split_* arrays as needed.
generate_repo_split_args_in() {
    repo_split_include=()
    repo_split_include_as=()

    # generate the repo_split_include array:
    generate_repo_split_include

    # generate the repo_split_include_as array:
    if [[ ! -z $include_as ]] && is_array "include_as"; then
        include_as_len=${#include_as[@]}
        include_as_index=0
        previous_i=""
        include_key_index=0
        valid_include_keys=()

        # get all keys of the include_as odd indices
        # these must be excluded from the directory part
        # of the next iteration
        while [[ $include_key_index -lt $include_as_len ]]; do
            if [[ $((include_key_index%2)) -eq 1 ]]; then
                if [[ ${include_as[include_key_index]} != "$i" ]]; then
                    valid_include_keys+=("${include_as[include_key_index]}")
                fi
            fi
            ((include_key_index+=1))
        done

        while [[ $include_as_index -lt $include_as_len ]]; do
            i=${include_as[include_as_index]}

            if [[ $((include_as_index%2)) -eq 0 ]]; then
                # even, this will be used on the next iteration
                previous_i="$i"
            else
                if [[ $i == "" || $i == " " ]]; then
                    i="./"
                fi
                if [[ -d $i ]]; then
                    echo "INCLUDING EVERYTHING IN DIRECTORY $i AS $previous_i"
                    # iterate all files in i, including files that start with dot
                    for item in "${i%*/}"/* "${i%*/}"/.[^.]*; do
                        # remove the common prefix/suffic
                        # so the paths line up properly
                        remove_common=true
                        if [[ $item == "./"* ]]; then
                            item="${item:2}"
                            remove_common=false
                        fi
                        if [[ $item == ".git" ]]; then
                            # no need to iterate over the .git directory
                            continue
                        fi
                        all_files=$(get_all_files_from "$item")
                        for file in $all_files; do
                            if ! does_item_match_any_of "$file" "${repo_split_include[@]}" ; then
                                # it does not match any of the include=() strings
                                # so we will add a repo split arg:
                                # but we also need to check if this is one of the
                                # other include_as=() strings
                                # if it is, then it will be included 
                                if ! does_item_match_any_of "$file" "${valid_include_keys[@]}" ; then
                                    # echo "REPO SPLIT ARG: --path-rename $file:$previous_i/$file"
                                    # echo "previous i: $previous_i, file: $file"
                                    input_file="$file"
                                    if [[ $remove_common == true ]]; then
                                        file="${file#*/}"
                                    fi

                                    if [[ "${previous_i: -1}" == "/" ]]; then
                                        if [[ ! -z $verbose ]]; then echo "$previous_i$file" ; fi
                                        # echo "including $input_file as $previous_i$file"
                                        # no need to add a slash, it already has one
                                        repo_split_include_as+=("$input_file:$previous_i$file")
                                    else
                                        if [[ ! -z $verbose ]]; then echo "$previous_i/$file" ; fi
                                        # echo "including $input_file as $previous_i/$file"
                                        repo_split_include_as+=("$input_file:$previous_i/$file")
                                    fi
                                fi
                            fi
                        done
                    done
                else
                    echo "INCLUDING $i AS $previous_i"
                    # echo "$i is a file, adding $i:$previous_i"
                    # echo "LOCAL $i IS A FILE, ADD REPO SPLIT ARGS AS IS:"
                    repo_split_include_as+=("$i:$previous_i")
                fi
            fi
            ((include_as_index+=1))
        done
    fi
}


# using the previously defined arrays:
# repo_split_include, repo_split_include_as,
# repo_split_exclude.
# creates the variables: exclude_path_str
# include_path_str, include_as_path_str
# which are used in the call(s) to git-filter-repo
generate_repo_split_strings_out() {
    exclude_path_str=""
    include_path_str=""
    include_as_path_str=""
    for i in ${repo_split_include[@]}; do
        if [[ -z $dry_run ]]; then echo "INCLUDING: $i"; fi
        include_path_str="$include_path_str--path $i "
    done
    for i in ${repo_split_include_as[@]}; do
        if [[ -z $dry_run ]]; then echo "INCLUDING AS: $i"; fi
        include_as_path_str="$include_as_path_str--path-rename $i "
    done
    for i in ${repo_split_exclude[@]}; do
        if [[ -z $dry_run ]]; then echo "EXCLUDING: $i"; fi
        exclude_path_str="$exclude_path_str--path $i "
    done
}

# using the previously defined array: repo_split_include_as,
# creates the variable: include_as_path_str
# which is used in the call(s) to git-filter-repo
generate_repo_split_strings_in() {
    include_as_path_str=""
    for i in ${repo_split_include_as[@]}; do
        include_as_path_str="$include_as_path_str--path-rename $i "
    done
}
