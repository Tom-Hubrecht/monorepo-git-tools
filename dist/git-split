#!/usr/bin/env bash
# git-split
# a custom git command to split out/in portions of a repository
# 
# Copyright (C) 2020, Nikita Skobov <nskobov.websites@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, specifically version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# prefixed ECS: exit code success
# or ECF: exit code failure
ecf_missing_input=1
ecf_failed_to_find_input_file=2
ecf_source_failure=3
ecf_invalid_input_file=4
ecf_failed_to_find_toplevel=5
ecf_failed_to_make_output_branch=6
ecf_failed_to_find_merge_branch=7

# variables related to documentation
# used in the print_usage function
doc_program_name="git split"
doc_author="Nikita Skobov"
doc_author_email="skobo002@umn.edu"
doc_version="1.1.1"
doc_last_updated="2020-05-23"
doc_copyright="Copyright (C) 2020 $doc_author

$doc_program_name is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under the terms of the
GNU Affero General Public License as published by
the Free Software Foundation, version 3, and no later.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>."
doc_synopsis=(
    "out <repo_file> [OPTIONS]"
    "in  <repo_file> [OPTIONS]"
)
doc_commands=(
    "out"
"Given a repo_file that defines how a repository should be split, git split out will take all paths defined in the repo_file and rewrite the repository's history into a new branch. This new branch will only include the history for the files specified in the repo_file.
.sp
You will then be left with a branch that can be considered as its own seperate repository (because it most likely doesn't share any common ancestor commits with your previous branch)."

    "in"
"Given a repo_file that defines how a repository should be split, git split in will take the remote_repo (or github.com/\$username/\$repo_name if remote_repo is not provided), and create a new empty branch based on the remote_repo. Then it will take all of the include and include_as paths defined in the repo_file and rewrite the repository's history on the branch that it just created. This new branch will only include the history for the files specified in the repo_file.
.sp
You will then be left with a branch that can be considered as its own seperate repository (because it most likely doesn't share any common ancestor commits with your previous branch)."
)
doc_global_options=(
    "-h, --help"
    "print help and exit"
    "--dry-run"
    "does not actually modify/do anything. Just outputs the commands that it would do without the --dry-run option present."
    "--output-branch <branch_name>"
    "the name of the branch that will be created"
)
doc_split_in_option_merge_branch='the '\
'merge branch option lets you split in '\
'from a local branch instead of a remote repository. '\
'<branch_name> must be a name of a branch that exists in your '\
'local repository.'
doc_split_in_options=(
    "Options for split in:"
    "--merge-branch <branch_name>"
    "$doc_split_in_option_merge_branch"
)
doc_custom_sections=(
    "doc_split_in_options"
)

# rfv: Repo File Variables
rfv_valid_variable_names=(
    "remote_repo"
    "remote_branch"
    "repo_name"
    "username"
    "include"
    "include_as"
    "exclude"
)
rfv_remote_repo=(
    "string"
    "optional"
    "A valid git repo uri. Can be a local file location, remote url, ssh url, etc. Only used for 'git split in'. It is used as the value of 'git pull <remote_repo>'. It is optional because by default, 'git split in' will use 'https://github.com/<username>/<repo_name>'"
)
rfv_remote_branch=(
    "string"
    "optional"
    "A valid remote branch name. Only used for 'git split in'. If provided, 'git split in' will pull from this remote branch instead of from master."
)
rfv_repo_name=(
    "string"
    "required"
    "The name of the repo. If running 'git split out', this is simply the name of the output branch created by default. For 'git split out', this is used for running 'git pull https://github.com/<username>/<repo_name>' if 'remote_repo' is not provided. Also for 'git split in', the output branch by default will be '<repo_name>-reverse'"
)
rfv_username=(
    "string"
    "conditional"
    "GitHub username. Only required for 'git split in' and if <remote_repo> is not provided. Used for the running 'git pull https://github.com/<username>/<repo_name'"
)
rfv_include=(
    "array|string"
    "conditional"
    "Includes the source repository files/directories exactly as is, without changing the paths. Specify a single include path as a string, otherwise multiple paths as an array of strings. Only used for 'git split out'. Only required if using 'git split out' and <include_as> is not provided. 'git split out' will take all of the include paths and rewrite the history as if those paths were the only thing in the repository."
)
rfv_include_as=(
    "array"
    "conditional"
    "An array of file paths, where every even path is a source path, and every odd path is a destination path. Includes the source repository paths as the destination paths. Only required if <include> is not provided. For 'git split out' the source paths are the paths relative to the root of your current branch, and the destination paths are what the source paths will be renamed to in the output branch. For 'git split in', it is the reverse. ie: the destination paths are the paths of the remote repository, and they will be renamed as the paths of the local repository."
)
rfv_exclude=(
    "array|string"
    "optional"
    "Exclude the source repository paths from being present in the destination. Only used for 'git split out'. Specify a single exclude path as a string, otherwise multiple paths as an array of strings. Note that the exclude paths get applied after the include paths. So you would first include the paths you want, and if there are sub-paths within the included path, you can explicitly exclude those that you do not wish to be present."
)

# prints the usage and exits
# takes argument: $1
# the exit code
print_usage_and_exit() {
    local exit_code="${1:-"0"}"
    local usage_string="$doc_program_name"
    local synopsis=""
    local global_options=""
    local extra_sections=""
    local ind=0

# needs to be indented poorly
# so that newlines work properly in strings:
for i in "${doc_synopsis[@]}"; do
if [[ $ind -eq 0 ]]; then
synopsis="${synopsis}usage: $doc_program_name $i
"
else
synopsis="$synopsis   or: $doc_program_name $i
"
fi
((ind+=1))
done
ind=0
for i in "${doc_global_options[@]}"; do
if [[ $ind -eq 0 ]]; then
global_options="$global_options
$i"
ind=1
else
global_options="$global_options
\t$i
"
ind=0
fi
done
for i in "${doc_custom_sections[@]}"; do
local -n array="$i"
extra_sections="$extra_sections
${array[0]}
"
ind=1
while [[ $ind -lt ${#array[@]} ]]; do

if [[ $((ind%2)) -eq 1 ]]; then
extra_sections="$extra_sections
${array[ind]}"
else
extra_sections="$extra_sections
\t${array[ind]}
"
fi
((ind+=1))
done
done

local usage_string="$synopsis
Global Options:
$global_options
$extra_sections"

    echo -e "$usage_string"
    exit $exit_code
}

# args: $1 = the file to source.
# tries to source the file and
# returns whether or not the source
# was successful
source_without_error() {
    source "$1" > /dev/null 2>&1
    return $?
}

# args: $1 the name of the variable to check.
# returns true if variable is an array
# false otherwise
is_array() {
    if [[ "$(declare -p $1)" =~ "declare -a" ]]; then
        return 0
    fi
    return 1
}

# args: $1 the name of the branch to check
# returns true if the branch exists, false otherwise
branch_exists() {
    local it_exists=$(git branch --list $1 2>&1)
    if [[ ! -z $it_exists ]]; then
        return 0
    fi
    return 1
}

make_orphan_branch_without_error() {
    # create a new empty branch
    git checkout --orphan "$1" 2>&1
    if [[ $? != "0" ]]; then
        echo "Error creating an orphan branch: $1"
        return 1
    fi

    # woah this looks scary right?
    # normally yes, but we are on an orphan branch
    # which means that we still have the files from our
    # previous branch, and git is saying that we are
    # ready to commit them, but we dont want to commit because
    # we want to be on an empty branch. We can safely rm everything from
    # our git directory because we will get them back when we checkout
    # back to our previous branch.
    # NOTE THIS ONLY REMOVES FILES/FOLDERS THAT WERE COMMITED
    # THIS DOES NOT REMOVE UNCOMMITED FILES/FOLDERS.
    git rm -rf . > /dev/null 2>&1
    if [[ $? != "0" ]]; then
        echo "Error clearing out the orphan branch: $1"
        return 1
    fi

    return 0
}

# Checks if output branch of $1
# exists. If it already exists returns false.
# Otherwise, it creates the branch and returns
# true if there was no error.
make_output_branch_without_error() {
    if branch_exists "$1"; then
        echo "The branch $1 already exists."
        echo "Please use a different output repo name via the option:"
        echo "--output-branch \"some_new_branch\""
        echo "Or delete the branch and run this again."
        return 1
    fi
    echo "MAKING BRANCH: $1"
    git checkout -b "$1"
    if [[ $? != "0" ]]; then
        echo "Failed to create output branch: $1"
        return 1
    fi
    return 0
}

# Changes to the git repo's root directory.
# returns true if there was no error,
# false otherwise.
cd_into_toplevel_without_error() {
    repo_absolute_path=$(git rev-parse --show-toplevel 2>&1)
    if [[ $repo_absolute_path == *"fatal: not a git repo"* ]]; then
        echo "Failed to find git toplevel directory"
        echo "This script must be ran from within a git repository"
        return 1
    fi

    # TODO: should we do printouts?
    # echo "Changing to repo: $repo_absolute_path"
    cd "$repo_absolute_path" > /dev/null 2>&1
    return $?
}

# echoes out the current branch name
get_current_branch_name() {
    echo "$(git rev-parse --abbrev-ref HEAD)"
}
# if compiling this file individually, use:
# import ./helpers.bsc
# otherwise helpers.bsc already included from git-split.bsc

# assumes that the input file has been sourced
# validates the variables that the input file has set.
# takes arg: $1 = the name of the file that was sourced.
# echoes out error message and returns false if invalid.
# otherwise returns true
input_file_valid_out() {
    if [[ -z $repo_name ]]; then
        echo "The file: $1 does not include a 'repo_name' variable"
        echo "To split out a subrepo, it must include a repo name"
        return 1
    elif [[ -z $include && -z $include_as ]]; then
        echo "The file: $1 does not have an 'include' or an 'include_as' variable"
        echo "To split out a subrepo, the input file must contain at least one include file/folder"
        return 1
    elif [[ ! -z $include_as ]] && ! is_array "include_as"; then
        echo "The file: $1 contains an include_as variable, but this variable is not an array"
        echo "To use include_as functionality, make sure it is an array"
        return 1
    elif [[ ! -z $include_as ]] && [[ ! $((${#include_as[@]} % 2)) -eq 0 ]]; then
        echo "include_as array provided, but it has an odd length"
        echo "include_as must be even so every even argument"
        echo "is the source file, and every odd argument"
        echo "is the desired destination"
        return 1
    fi
    return 0
}



# sources an input file that contains
# variables needed for splitting out
# a repository and (optionally) changing paths.
# it uses previously defined variables:
# dry_run.
# If dry_run is defined, it will simply
# print out the commands instead of running them.
split_out() {
    get_arg output_branch,o "$@"
    if [[ -z $1 ]]; then
        echo "Missing required input file"
        echo ""
        print_usage_and_exit $ecf_missing_input
    elif [[ ! -f $1 ]]; then
        echo "Failed to find input file: $1"
        echo ""
        print_usage_and_exit $ecf_failed_to_find_input_file
    elif ! source_without_error "$1"; then
        echo "Failed to source input file: $1"
        echo "Is this a shell script file?"
        echo ""
        print_usage_and_exit $ecf_source_failure
    elif ! input_file_valid_out "$1"; then
        echo ""
        print_usage_and_exit $ecf_invalid_input_file
    elif ! cd_into_toplevel_without_error; then
        echo ""
        print_usage_and_exit $ecf_failed_to_find_toplevel
    fi

    # this relies on include, include_as, or exclude variables
    # being defined.
    # it creates the following arrays:
    # repo_split_include, repo_split_include_as, repo_split_exclude
    generate_repo_split_args_out
    # and then creates include_path_str, exclude_path_str, include_as_path_str
    generate_repo_split_strings_out

    local output_branch_name=${output_branch:-"$repo_name"}
    if [[ ! -z $dry_run ]]; then
        echo "git checkout -b $output_branch_name"
    elif ! make_output_branch_without_error "$output_branch_name"; then
        echo ""
        print_usage_and_exit $ecf_failed_to_make_output_branch
    fi

    # Now run the git filter-repo command with the generated arguments:
    # exclude anything not in the include paths:
    # only run the command if dry_run is unset
    # echo out the command no matter what
    echo "git filter-repo $include_path_str --refs $output_branch_name --force"
    if [[ -z $dry_run ]]; then
        git filter-repo $include_path_str --refs $output_branch_name --force
    fi

    # exclude anything specified by the exclude paths:
    if [[ ! -z $exclude_path_str ]]; then
        echo "git filter-repo $exclude_path_str --invert-paths --refs $output_branch_name --force"
        if [[ -z $dry_run ]]; then
            git filter-repo $exclude_path_str --invert-paths --refs $output_branch_name --force
        fi
    fi

    # change the paths from source to dest
    # ie: renaming a private repo structure to a
    # public repo structure while preserving commits
    if [[ ! -z $include_as_path_str ]]; then
        echo "git filter-repo $include_as_path_str --refs $output_branch_name --force"
        if [[ -z $dry_run ]]; then
            git filter-repo $include_as_path_str --refs $output_branch_name --force
        fi
    fi
}
# if compiling this file individually, use:
# import ./helpers.bsc
# otherwise helpers.bsc already included from git-split.bsc

# assumes that the input file has been sourced
# validates the variables that the input file has set.
# takes arg: $1 = the name of the file that was sourced.
# echoes out error message and returns false if invalid.
# otherwise returns true
input_file_valid_in() {
    if [[ -z $repo_name ]]; then
        echo "The file: $1 does not include a 'repo_name' variable"
        echo "To split in a subrepo, it must include a repo name"
        return 1
    elif [[ -z $merge_branch ]] && [[ -z $remote_repo ]] && [[ -z $repo_name || -z $username ]]; then
        echo "The file: $1 does not contain a remote source to pull from"
        echo "You must provide either a 'remote_repo' URL as a string"
        echo "Or a 'repo_name' and a 'username'"
        echo "Alternatively, you can provide a '--merge-branch' option"
        echo "to use a local branch to merge in from instead of merging in"
        echo "from a remote source"
        return 1
    elif [[ -z $include && -z $include_as ]]; then
        echo "The file: $1 does not have an 'include' or an 'include_as' variable"
        echo "To split in a subrepo, the input file must contain at least one include file/folder"
        return 1
    elif [[ ! -z $include_as ]] && ! is_array "include_as"; then
        echo "The file: $1 contains an include_as variable, but this variable is not an array"
        echo "To use include_as functionality, make sure it is an array"
        return 1
    elif [[ ! -z $include_as ]] && [[ ! $((${#include_as[@]} % 2)) -eq 0 ]]; then
        echo "include_as array provided, but it has an odd length"
        echo "include_as must be even so every even argument"
        echo "is the source file, and every odd argument"
        echo "is the desired destination"
        return 1
    fi
    return 0
}

# given a list of arguments,
# the first being the name that you are searching for
# and the rest is an arbitrary list or keywords.
# returns true if the list of key words contains
# the first argument.
does_item_match_any_of() {
    local item_name="$1"
    shift
    for thing in "$@"; do
        if [[ $item_name == "$thing"* ]]; then
            return 0
        fi
    done

    return 1
}

# given a single argument: $1
# iterate over that folder, recursively
# and echo out a list of files, ignoring
# files that are git-ignored, and files
# that are not committed in the repo.
get_all_files_from() {
    local f_or_d="$1"

    if [[ -d "$f_or_d" ]]; then
        # all files/folders in f_or_d/ including
        # files/folders that start with a dot:
        for next in $f_or_d/* $f_or_d/.[^.]* ; do
            if ! git check-ignore "$next" > /dev/null 2>&1 ; then
                # only recurse as long as this is not a .gitignored file
                get_all_files_from "$next"
            fi
        done
    else
        # only echo out the file
        # if it actually has history in the git repo
        if git cat-file -e HEAD:"$f_or_d" > /dev/null 2>&1 ; then
            echo "$f_or_d"
        fi
    fi
}

# relies on previously defined variables:
# uses $merge_branch if set. If merge_branch
# is set, it does git merge $merge_branch
# otherwise it does
# git pull https://github.com/username/repo_name
populate_empty_branch_with_remote_commits() {
    # # populate the empty branch with the current master of the remote
    if [[ ! -z $merge_branch ]]; then
        # if user provided merge branch, use that instead of pull:
        if [[ ! -z $dry_run ]]; then
            echo "git merge $merge_branch"
        else
            git merge $merge_branch
        fi
    else
        if [[ ! -z $dry_run ]]; then
            echo "git pull $@"
        else
            echo "git pull $@"
            git pull $@
        fi
    fi
}


# sources an input file that contains
# variables needed for splitting in
# a remote repository and (optionally) changing paths.
# back into this local repository.
# it uses previously defined variables:
# dry_run.
# If dry_run is defined, it will simply
# print out the commands instead of running them.
split_in() {
    # get a --merge-branch option if the user supplied it
    get_arg merge_branch,m "$@"
    get_arg verbose "$@"
    get_arg output_branch,o "$@"

    if [[ -z $1 ]]; then
        echo "Missing required input file"
        echo ""
        print_usage_and_exit $ecf_missing_input
    elif [[ ! -f $1 ]]; then
        echo "Failed to find input file: $1"
        echo ""
        print_usage_and_exit $ecf_failed_to_find_input_file
    elif ! source_without_error "$1"; then
        echo "Failed to source input file: $1"
        echo "Is this a shell script file?"
        echo ""
        print_usage_and_exit $ecf_source_failure
    elif ! input_file_valid_in "$1"; then
        echo ""
        print_usage_and_exit $ecf_invalid_input_file
    elif ! cd_into_toplevel_without_error; then
        echo ""
        print_usage_and_exit $ecf_failed_to_find_toplevel
    elif [[ ! -z $merge_branch ]] && ! branch_exists "$merge_branch"; then
        echo "You provided a merge branch: $merge_branch"
        echo "That does not exist."
        echo ""
        print_usage_and_exit $ecf_failed_to_find_merge_branch
    fi

    local output_branch_name=${output_branch:-"$repo_name-reverse"}
    if [[ ! -z $dry_run ]]; then
        echo "git checkout --orphan $output_branch_name"
        echo "git rm -rf . > /dev/null"
    elif ! make_orphan_branch_without_error "$output_branch_name"; then
        echo ""
        print_usage_and_exit $ecf_failed_to_make_output_branch
    fi

    local remote_uri="https://github.com/$username/$repo_name"
    if [[ ! -z $remote_repo ]]; then
        remote_uri="$remote_repo"
    fi
    if [[ ! -z $remote_branch ]]; then
        remote_uri="$remote_uri $remote_branch"
    fi
    populate_empty_branch_with_remote_commits $remote_uri
    generate_repo_split_args_in
    generate_repo_split_strings_in

    if [[ ! -z $include_as_path_str ]]; then
        echo "git filter-repo --force --refs $output_branch_name $include_as_path_str"
        if [[ -z $dry_run ]]; then
            git filter-repo --force --refs $output_branch_name $include_as_path_str
        fi
    fi
}
# These are helper functions
# that specifically apply to using
# git-filter-repo

# generates the repo_split_include array
# from the previously defined include variable
generate_repo_split_include() {
    if [[ ! -z $include ]] && is_array "include"; then
        for i in ${include[@]}; do
            repo_split_include+=($i)
        done
    elif [[ ! -z $include ]]; then
        # its a single string
        repo_split_include+=($include)
    fi
}

# generates the repo_split_exclude array
# from the previously defined exclude variable
generate_repo_split_exclude() {
    if [[ ! -z $exclude ]] && is_array "exclude"; then
        # its an array
        for i in ${exclude[@]}; do
            repo_split_exclude+=($i)
        done
    elif [[ ! -z $exclude ]]; then
        # its a single string
        repo_split_exclude+=($exclude)
    fi
}

# creates 3 repo split variables:
# repo_split_exclude, repo_split_include, and
# repo_split_include_as. Then iterates over
# the user defined include, or include_as, or
# exclude variables, and fills in
# the repo_split_* arrays as needed.
generate_repo_split_args_out() {
    repo_split_exclude=()
    repo_split_include=()
    repo_split_include_as=()

    generate_repo_split_include
    generate_repo_split_exclude

    if [[ ! -z $include_as ]] && is_array "include_as"; then
        include_as_len=${#include_as[@]}
        include_as_index=0
        previous_i=""
        while [[ $include_as_index -lt $include_as_len ]]; do
            i=${include_as[include_as_index]}
            if [[ $((include_as_index%2)) -eq 0 ]]; then
                # even
                previous_i="$i"
                repo_split_include+=($i)
            else
                repo_split_include_as+=("$previous_i:$i")
            fi
            ((include_as_index+=1))
        done
    fi
}

# creates 2 repo split variables:
# repo_split_include, and
# repo_split_include_as. Then iterates over
# the user defined include, or include_as, or
# variables, and fills in
# the repo_split_* arrays as needed.
generate_repo_split_args_in() {
    repo_split_include=()
    repo_split_include_as=()

    # generate the repo_split_include array:
    generate_repo_split_include

    # generate the repo_split_include_as array:
    if [[ ! -z $include_as ]] && is_array "include_as"; then
        include_as_len=${#include_as[@]}
        include_as_index=0
        previous_i=""
        include_key_index=0
        valid_include_keys=()

        # get all keys of the include_as odd indices
        # these must be excluded from the directory part
        # of the next iteration
        while [[ $include_key_index -lt $include_as_len ]]; do
            if [[ $((include_key_index%2)) -eq 1 ]]; then
                if [[ ${include_as[include_key_index]} != "$i" ]]; then
                    valid_include_keys+=("${include_as[include_key_index]}")
                fi
            fi
            ((include_key_index+=1))
        done

        while [[ $include_as_index -lt $include_as_len ]]; do
            i=${include_as[include_as_index]}

            if [[ $((include_as_index%2)) -eq 0 ]]; then
                # even, this will be used on the next iteration
                previous_i="$i"
            else
                if [[ $i == "" || $i == " " ]]; then
                    i="./"
                fi
                if [[ -d $i ]]; then
                    echo "INCLUDING EVERYTHING IN DIRECTORY $i AS $previous_i"
                    # iterate all files in i, including files that start with dot
                    for item in "${i%*/}"/* "${i%*/}"/.[^.]*; do
                        # remove the common prefix/suffic
                        # so the paths line up properly
                        remove_common=true
                        if [[ $item == "./"* ]]; then
                            item="${item:2}"
                            remove_common=false
                        fi
                        if [[ $item == ".git" ]]; then
                            # no need to iterate over the .git directory
                            continue
                        fi
                        all_files=$(get_all_files_from "$item")
                        for file in $all_files; do
                            if ! does_item_match_any_of "$file" "${repo_split_include[@]}" ; then
                                # it does not match any of the include=() strings
                                # so we will add a repo split arg:
                                # but we also need to check if this is one of the
                                # other include_as=() strings
                                # if it is, then it will be included 
                                if ! does_item_match_any_of "$file" "${valid_include_keys[@]}" ; then
                                    # echo "REPO SPLIT ARG: --path-rename $file:$previous_i/$file"
                                    # echo "previous i: $previous_i, file: $file"
                                    input_file="$file"
                                    if [[ $remove_common == true ]]; then
                                        file="${file#*/}"
                                    fi

                                    if [[ "${previous_i: -1}" == "/" ]]; then
                                        if [[ ! -z $verbose ]]; then echo "$previous_i$file" ; fi
                                        # echo "including $input_file as $previous_i$file"
                                        # no need to add a slash, it already has one
                                        repo_split_include_as+=("$input_file:$previous_i$file")
                                    else
                                        if [[ ! -z $verbose ]]; then echo "$previous_i/$file" ; fi
                                        # echo "including $input_file as $previous_i/$file"
                                        repo_split_include_as+=("$input_file:$previous_i/$file")
                                    fi
                                fi
                            fi
                        done
                    done
                else
                    echo "INCLUDING $i AS $previous_i"
                    # echo "$i is a file, adding $i:$previous_i"
                    # echo "LOCAL $i IS A FILE, ADD REPO SPLIT ARGS AS IS:"
                    repo_split_include_as+=("$i:$previous_i")
                fi
            fi
            ((include_as_index+=1))
        done
    fi
}


# using the previously defined arrays:
# repo_split_include, repo_split_include_as,
# repo_split_exclude.
# creates the variables: exclude_path_str
# include_path_str, include_as_path_str
# which are used in the call(s) to git-filter-repo
generate_repo_split_strings_out() {
    exclude_path_str=""
    include_path_str=""
    include_as_path_str=""
    for i in ${repo_split_include[@]}; do
        if [[ -z $dry_run ]]; then echo "INCLUDING: $i"; fi
        include_path_str="$include_path_str--path $i "
    done
    for i in ${repo_split_include_as[@]}; do
        if [[ -z $dry_run ]]; then echo "INCLUDING AS: $i"; fi
        include_as_path_str="$include_as_path_str--path-rename $i "
    done
    for i in ${repo_split_exclude[@]}; do
        if [[ -z $dry_run ]]; then echo "EXCLUDING: $i"; fi
        exclude_path_str="$exclude_path_str--path $i "
    done
}

# using the previously defined array: repo_split_include_as,
# creates the variable: include_as_path_str
# which is used in the call(s) to git-filter-repo
generate_repo_split_strings_in() {
    include_as_path_str=""
    for i in ${repo_split_include_as[@]}; do
        include_as_path_str="$include_as_path_str--path-rename $i "
    done
}

# usage
# get_arg file_extension,e "$@"
# matches: "--file-extension <value>" or "-e <value>"
# to use the output:
# echo "what is my file extension? $file_extension"
# note in the usage, the long form will be the variable
# name, so short form must come after long form, if at all

get_arg () 
{ 
    local looking_for=();
    IFS=',' read -ra looking_for <<< "$1";
    shift;
    local -n outvar=${looking_for[0]};
    while (( "$#" )); do
        case "$1" in 
            -* | --*=)
                local opt_value="$2";
                local opt_name="${1,,}";
                local stripped_name="${opt_name//-/_}";
                local strip_underscores="_";
                stripped_name="${stripped_name/$strip_underscores}";
                if [[ $stripped_name == "_"* ]]; then
                    stripped_name="${stripped_name/$strip_underscores}";
                fi;
                local found_match=false;
                for match in ${looking_for[@]};
                do
                    if [[ $stripped_name == $match ]]; then
                        if [[ -z $opt_value || $opt_value == "-"* ]]; then
                            outvar=true;
                        else
                            outvar="$opt_value";
                        fi;
                        found_match=true;
                        break;
                    fi;
                done;
                if [[ $found_match == true ]]; then
                    break;
                fi;
                if [[ $opt_value == "-"* ]]; then
                    shift;
                else
                    shift;
                    shift;
                fi
            ;;
            *)
                shift
            ;;
        esac;
    done
}

# I like a nice little space between the command
# and the output :)
echo ""

# if running the command as
# git split X Y Z
# X = $1, Y = $2, Z = $3
# similarly for git-split:
# git-split X Y Z
# X = $1, Y = $2, Z = $3
# git takes care of removing the git command name
# from the arg list


subcommand="$1"
get_arg dry_run "$@"
get_arg version "$@"

if [[ ! -z $version ]]; then
    echo "$doc_program_name version $doc_version ($doc_last_updated)"
    echo "$doc_copyright"
    exit 0
fi

if [[ -z $subcommand ]]; then
    print_usage_and_exit $ecf_missing_input
elif [[
    $subcommand == "help" || \
    $subcommand == "-h" || \
    $subcommand == "--help"
]]; then
    print_usage_and_exit 0
elif [[ $subcommand == "out" ]]; then
    shift
    split_out "$@"
elif [[ $subcommand == "in" ]]; then
    shift
    split_in "$@"
fi
